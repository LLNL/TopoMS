/*
 * Copyright (c) 2017 University of Utah 
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice,
 *    this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the copyright holder nor the names of its
 *    contributors may be used to endorse or promote products derived from
 *    this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
 * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 */

#ifndef TOPOLOGICAL_REGULAR_MASKED_GRID_H
#define TOPOLOGICAL_REGULAR_MASKED_GRID_H


#include <map>
#include <set>
#include "basic_types.h"
#include "vectors.h"
#include "regular_grid.h"
#include "topological_regular_grid.h"
#include "labeling.h"

namespace MSC {


    // TopologicalRegularGrid is a specialized class to work with the connectivity of a
    // regular 3d grid - with quantities derived from an input regular 3d grid.
    // This class handles no storage on its own - it simply
    // provides a mechanism for iterating over cells, iterating over facets and cofacets of cells
    // and answering questions about a cell, such as its dimension, whether or not it sits on a
    // boundary, what its coordinates are, etc.
    //
    // This class uses a cell index numbering to make neighborhood queries fast - simply reduces
    // to adding a pre-computed offset to the current cell id. E.g. For a nonperiodic grid with X*Y*Z values,
    // the indices generated by this class uses a grid of size (2X-1)*(2Y-1)*(2Z-1), basically
    // representing every cell (vertex, edge, quad, hex) with a unique id, such that facets/cofacets
    // of a cell id can be computed by simply adding an offset to the  cell id.

    // NOTE: we use unsigned long longs for the axes, since we do not want any arithmetic we do with them
    // to be accidentally truncated to 32-bit integers.
    class CellTester {
    public:
        virtual bool TestCell(INDEX_TYPE id) {
            return true;
        }
    };

    class CellTesterDefaultTrue : public CellTester {
    public:
        virtual bool TestCell(INDEX_TYPE id) {
            return true;
        }
    };
    class CellTesterLaberInput : public CellTester {
    protected:
        DenseLabeling<char>* m_labeling;
    public:
        void SetLabeling(DenseLabeling<char>* inp) { m_labeling = inp; }
        virtual bool TestCell(INDEX_TYPE id) {
            return m_labeling->GetLabel(id) == 1;
        }
    };

    class TopologicalRegularMaskedGrid  : virtual public TopologicalRegularGrid {
    protected:
        CellTester* m_tester;

    public:
        bool InMesh(INDEX_TYPE id) const {
            return m_tester->TestCell(id);
        }
    public:
        class AllCellsIterator : public TopologicalRegularGrid::AllCellsIterator {
        protected:
            const TopologicalRegularMaskedGrid* const m_mesh;
        public:
            AllCellsIterator(TopologicalRegularMaskedGrid* m) :
                TopologicalRegularGrid::AllCellsIterator(m), m_mesh(m) {}

            AllCellsIterator(TopologicalRegularMaskedGrid* m, INDEX_TYPE start, INDEX_TYPE end) :
                TopologicalRegularGrid::AllCellsIterator(m, start, end), m_mesh(m) {}

            void begin() {
                TopologicalRegularGrid::AllCellsIterator::begin();
                while (TopologicalRegularGrid::AllCellsIterator::valid() && !
                    m_mesh->InMesh(TopologicalRegularGrid::AllCellsIterator::value()))
                    TopologicalRegularGrid::AllCellsIterator::advance();
            }
            void advance() {
                TopologicalRegularGrid::AllCellsIterator::advance();
                while (TopologicalRegularGrid::AllCellsIterator::valid() && !
                    m_mesh->InMesh(TopologicalRegularGrid::AllCellsIterator::value()))
                    TopologicalRegularGrid::AllCellsIterator::advance();
            }
            bool valid() const {
                return TopologicalRegularGrid::AllCellsIterator::valid();
            }
            INDEX_TYPE value() const {
                return TopologicalRegularGrid::AllCellsIterator::value();
            }
        };

        class DCellsIterator : public TopologicalRegularGrid::DCellsIterator {
        protected:
            const TopologicalRegularMaskedGrid* const m_mesh;
        public:
            DCellsIterator(TopologicalRegularMaskedGrid* mesh, DIM_TYPE dim) :
                TopologicalRegularGrid::DCellsIterator(mesh, dim), m_mesh(mesh) {}
            DCellsIterator(TopologicalRegularMaskedGrid* mesh, DIM_TYPE dim, INDEX_TYPE start, INDEX_TYPE end) :
                TopologicalRegularGrid::DCellsIterator(mesh, dim, start, end), m_mesh(mesh) {}

            void begin() {
                TopologicalRegularGrid::DCellsIterator::begin();
                while (TopologicalRegularGrid::DCellsIterator::valid() && !
                    m_mesh->InMesh(TopologicalRegularGrid::DCellsIterator::value()))
                    TopologicalRegularGrid::DCellsIterator::advance();
            }
            void advance() {
                TopologicalRegularGrid::DCellsIterator::advance();
                while (TopologicalRegularGrid::DCellsIterator::valid() && !
                    m_mesh->InMesh(TopologicalRegularGrid::DCellsIterator::value()))
                    TopologicalRegularGrid::DCellsIterator::advance();
            }
            bool valid() const {
                return TopologicalRegularGrid::DCellsIterator::valid();
            }
            INDEX_TYPE value() const {
                return TopologicalRegularGrid::DCellsIterator::value();
            }
        };

        //// also needs boundary!!! WILL USE IF rather than virutal function
        class FacetsIterator : public TopologicalRegularGrid::FacetsIterator {
        protected:
            const TopologicalRegularMaskedGrid* const m_mesh;




        public:
            FacetsIterator(const TopologicalRegularMaskedGrid *const mesh) :
                TopologicalRegularGrid::FacetsIterator(mesh), m_mesh(mesh) {}


            void begin(Vec3l const &coords) {
                TopologicalRegularGrid::FacetsIterator::begin(coords);
                while (TopologicalRegularGrid::FacetsIterator::valid() && !
                    m_mesh->InMesh(TopologicalRegularGrid::FacetsIterator::value()))
                    TopologicalRegularGrid::FacetsIterator::advance();
            }
            void begin(INDEX_TYPE const &cellid) {
                TopologicalRegularGrid::FacetsIterator::begin(cellid);
                while (TopologicalRegularGrid::FacetsIterator::valid() && !
                    m_mesh->InMesh(TopologicalRegularGrid::FacetsIterator::value()))
                    TopologicalRegularGrid::FacetsIterator::advance();
            }
            void advance() {
                TopologicalRegularGrid::FacetsIterator::advance();
                while (TopologicalRegularGrid::FacetsIterator::valid() && !
                    m_mesh->InMesh(TopologicalRegularGrid::FacetsIterator::value()))
                    TopologicalRegularGrid::FacetsIterator::advance();
            }
            bool valid() const {
                return TopologicalRegularGrid::FacetsIterator::valid();
            }
            INDEX_TYPE value() const {
                return TopologicalRegularGrid::FacetsIterator::value();
            }
        };

        //// also needs boundary!!! WILL USE IF rather than virutal function
        class CofacetsIterator : public TopologicalRegularGrid::CofacetsIterator {
        public:
            const TopologicalRegularMaskedGrid* const m_mesh;
            CofacetsIterator(TopologicalRegularMaskedGrid* mesh) :
            TopologicalRegularGrid::CofacetsIterator(mesh), m_mesh(mesh) {}


            void begin(Vec3l const &coords) {
                TopologicalRegularGrid::CofacetsIterator::begin(coords);
                while (TopologicalRegularGrid::CofacetsIterator::valid() && !
                    m_mesh->InMesh(TopologicalRegularGrid::CofacetsIterator::value()))
                    TopologicalRegularGrid::CofacetsIterator::advance();
            }
            void begin(INDEX_TYPE const &cellid) {
                TopologicalRegularGrid::CofacetsIterator::begin(cellid);
                while (TopologicalRegularGrid::CofacetsIterator::valid() && !
                    m_mesh->InMesh(TopologicalRegularGrid::CofacetsIterator::value()))
                    TopologicalRegularGrid::CofacetsIterator::advance();
            }
            void advance() {
                TopologicalRegularGrid::CofacetsIterator::advance();
                while (TopologicalRegularGrid::CofacetsIterator::valid() && !
                    m_mesh->InMesh(TopologicalRegularGrid::CofacetsIterator::value()))
                    TopologicalRegularGrid::CofacetsIterator::advance();
            }
            bool valid() const {
                return TopologicalRegularGrid::CofacetsIterator::valid();
            }
            INDEX_TYPE value() const {
                return TopologicalRegularGrid::CofacetsIterator::value();
            }
        };


        //// also needs boundary!!! WILL USE IF rather than virutal function
        class AdjacentCellsIterator : public TopologicalRegularGrid::AdjacentCellsIterator {
        protected:
            const TopologicalRegularMaskedGrid* const m_mesh;

        public:
            AdjacentCellsIterator(const TopologicalRegularMaskedGrid *const mesh) :
            TopologicalRegularGrid::AdjacentCellsIterator(mesh), m_mesh(mesh) {}


            void begin(Vec3l const &coords) {
                TopologicalRegularGrid::AdjacentCellsIterator::begin(coords);
                while (TopologicalRegularGrid::AdjacentCellsIterator::valid() && !
                    m_mesh->InMesh(TopologicalRegularGrid::AdjacentCellsIterator::value()))
                    TopologicalRegularGrid::AdjacentCellsIterator::advance();
            }
            void begin(INDEX_TYPE const &cellid) {
                TopologicalRegularGrid::AdjacentCellsIterator::begin(cellid);
                while (TopologicalRegularGrid::AdjacentCellsIterator::valid() && !
                    m_mesh->InMesh(TopologicalRegularGrid::AdjacentCellsIterator::value()))
                    TopologicalRegularGrid::AdjacentCellsIterator::advance();
            }
            void advance() {
                TopologicalRegularGrid::AdjacentCellsIterator::advance();
                while (TopologicalRegularGrid::AdjacentCellsIterator::valid() && !
                    m_mesh->InMesh(TopologicalRegularGrid::AdjacentCellsIterator::value()))
                    TopologicalRegularGrid::AdjacentCellsIterator::advance();
            }
            bool valid() const {
                return TopologicalRegularGrid::AdjacentCellsIterator::valid();
            }
            INDEX_TYPE value() const {
                return TopologicalRegularGrid::AdjacentCellsIterator::value();
            }
        };

        //// also needs boundary!!! WILL USE IF rather than virutal function
        class CellVerticesIterator : public TopologicalRegularGrid::CellVerticesIterator {

        protected:
          const TopologicalRegularMaskedGrid* const m_mesh;
        public:
            CellVerticesIterator(const TopologicalRegularMaskedGrid *const mesh) :
                TopologicalRegularGrid::CellVerticesIterator(mesh), m_mesh(mesh) {}


            void begin(Vec3l const &coords) {
                TopologicalRegularGrid::CellVerticesIterator::begin(coords);
                while (TopologicalRegularGrid::CellVerticesIterator::valid() && !
                    m_mesh->InMesh(TopologicalRegularGrid::CellVerticesIterator::value()))
                    TopologicalRegularGrid::CellVerticesIterator::advance();
            }
            void begin(INDEX_TYPE const &cellid) {
                TopologicalRegularGrid::CellVerticesIterator::begin(cellid);
                while (TopologicalRegularGrid::CellVerticesIterator::valid() && !
                    m_mesh->InMesh(TopologicalRegularGrid::CellVerticesIterator::value()))
                    TopologicalRegularGrid::CellVerticesIterator::advance();
            }
            void advance() {
                TopologicalRegularGrid::CellVerticesIterator::advance();
                while (TopologicalRegularGrid::CellVerticesIterator::valid() && !
                    m_mesh->InMesh(TopologicalRegularGrid::CellVerticesIterator::value()))
                    TopologicalRegularGrid::CellVerticesIterator::advance();
            }
            bool valid() const {
                return TopologicalRegularGrid::CellVerticesIterator::valid();
            }
            INDEX_TYPE value() const {
                return TopologicalRegularGrid::CellVerticesIterator::value();
            }
        };





    public:

        TopologicalRegularMaskedGrid(RegularGrid* base_grid): TopologicalRegularGrid(base_grid)
        {
        }

        void SetTester(CellTester* tester) { m_tester = tester; }

        virtual  ~TopologicalRegularMaskedGrid() {
            printf("delete: TopologicalRegularMaskedGrid \n");
        }



    };

}


#endif
