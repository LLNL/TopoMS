/*
 * Copyright (c) 2017 University of Utah 
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice,
 *    this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the copyright holder nor the names of its
 *    contributors may be used to endorse or promote products derived from
 *    this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
 * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 */

#ifndef TOPOLOGICAL_REGULAR_MASKED_GRID_H
#define TOPOLOGICAL_REGULAR_MASKED_GRID_H


#include "topological_regular_grid.h"
#include "labeling.h"

namespace MSC {

// ----------------------------------------------------------------------------------
// ----------------------------------------------------------------------------------
class CellTester {
public:
    virtual bool TestCell(INDEX_TYPE id) {  return true;    }
};

class CellTesterDefaultTrue : public CellTester {
public:
    virtual bool TestCell(INDEX_TYPE id) {  return true;    }
};

class CellTesterLaberInput : public CellTester {
protected:
    DenseLabeling<char>* m_labeling;
public:
    void SetLabeling(DenseLabeling<char>* inp) { m_labeling = inp;                      }
    virtual bool TestCell(INDEX_TYPE id) {       return m_labeling->GetLabel(id) == 1;  }
};

// ----------------------------------------------------------------------------------
// ----------------------------------------------------------------------------------
/**
// TopologicalRegularGrid is a specialized class to work with the connectivity of a
// regular 3d grid - with quantities derived from an input regular 3d grid.
// This class handles no storage on its own - it simply
// provides a mechanism for iterating over cells, iterating over facets and cofacets of cells
// and answering questions about a cell, such as its dimension, whether or not it sits on a
// boundary, what its coordinates are, etc.
//
// This class uses a cell index numbering to make neighborhood queries fast - simply reduces
// to adding a pre-computed offset to the current cell id. E.g. For a nonperiodic grid with X*Y*Z values,
// the indices generated by this class uses a grid of size (2X-1)*(2Y-1)*(2Z-1), basically
// representing every cell (vertex, edge, quad, hex) with a unique id, such that facets/cofacets
// of a cell id can be computed by simply adding an offset to the  cell id.

// NOTE: we use unsigned long longs for the axes, since we do not want any arithmetic we do with them
// to be accidentally truncated to 32-bit integers.
*/

class TopologicalRegularMaskedGrid  : virtual public TopologicalRegularGrid {
protected:
    CellTester* m_tester;

public:
    TopologicalRegularMaskedGrid(RegularGrid* base_grid):
        TopologicalRegularGrid(base_grid){}

    void SetTester(CellTester* tester) {    m_tester = tester;              }
    bool InMesh(INDEX_TYPE id) const {      return m_tester->TestCell(id);  }

    virtual  ~TopologicalRegularMaskedGrid() {}

    // -----------------------------------------------------------------------------
    class AllCellsIterator : public TopologicalRegularGrid::AllCellsIterator {
    protected:
        const TopologicalRegularMaskedGrid* const m_mesh;
    public:
        AllCellsIterator(TopologicalRegularMaskedGrid* m) :
            TopologicalRegularGrid::AllCellsIterator(m), m_mesh(m) {}

        AllCellsIterator(TopologicalRegularMaskedGrid* m, INDEX_TYPE start, INDEX_TYPE end) :
            TopologicalRegularGrid::AllCellsIterator(m, start, end), m_mesh(m) {}

        void begin() {
            TopologicalRegularGrid::AllCellsIterator::begin();
            while (TopologicalRegularGrid::AllCellsIterator::valid() &&  !m_mesh->InMesh(TopologicalRegularGrid::AllCellsIterator::value()))
                TopologicalRegularGrid::AllCellsIterator::advance();
        }
        void advance() {
            TopologicalRegularGrid::AllCellsIterator::advance();
            while (TopologicalRegularGrid::AllCellsIterator::valid() && !m_mesh->InMesh(TopologicalRegularGrid::AllCellsIterator::value()))
                TopologicalRegularGrid::AllCellsIterator::advance();
        }
        bool valid() const {        return TopologicalRegularGrid::AllCellsIterator::valid();   }
        INDEX_TYPE value() const {  return TopologicalRegularGrid::AllCellsIterator::value();   }
    };

    // -----------------------------------------------------------------------------
    class DCellsIterator : public TopologicalRegularGrid::DCellsIterator {
    protected:
        const TopologicalRegularMaskedGrid* const m_mesh;
    public:
        DCellsIterator(TopologicalRegularMaskedGrid* mesh, DIM_TYPE dim) :
            TopologicalRegularGrid::DCellsIterator(mesh, dim), m_mesh(mesh) {}
        DCellsIterator(TopologicalRegularMaskedGrid* mesh, DIM_TYPE dim, INDEX_TYPE start, INDEX_TYPE end) :
            TopologicalRegularGrid::DCellsIterator(mesh, dim, start, end), m_mesh(mesh) {}

        void begin() {
            TopologicalRegularGrid::DCellsIterator::begin();
            while (TopologicalRegularGrid::DCellsIterator::valid() && !m_mesh->InMesh(TopologicalRegularGrid::DCellsIterator::value()))
                TopologicalRegularGrid::DCellsIterator::advance();
        }
        void advance() {
            TopologicalRegularGrid::DCellsIterator::advance();
            while (TopologicalRegularGrid::DCellsIterator::valid() && !m_mesh->InMesh(TopologicalRegularGrid::DCellsIterator::value()))
                TopologicalRegularGrid::DCellsIterator::advance();
        }
        bool valid() const {        return TopologicalRegularGrid::DCellsIterator::valid(); }
        INDEX_TYPE value() const {  return TopologicalRegularGrid::DCellsIterator::value(); }
    };

    // -----------------------------------------------------------------------------
    //// also needs boundary!!! WILL USE IF rather than virutal function
    class FacetsIterator : public TopologicalRegularGrid::FacetsIterator {
    protected:
        const TopologicalRegularMaskedGrid* const m_mesh;
    public:
        FacetsIterator(const TopologicalRegularMaskedGrid *const mesh) :
            TopologicalRegularGrid::FacetsIterator(mesh), m_mesh(mesh) {}

        void begin(Vec3l const &coords) {
            TopologicalRegularGrid::FacetsIterator::begin(coords);
            while (TopologicalRegularGrid::FacetsIterator::valid() && !m_mesh->InMesh(TopologicalRegularGrid::FacetsIterator::value()))
                TopologicalRegularGrid::FacetsIterator::advance();
        }
        void begin(INDEX_TYPE const &cellid) {
            TopologicalRegularGrid::FacetsIterator::begin(cellid);
            while (TopologicalRegularGrid::FacetsIterator::valid() && !m_mesh->InMesh(TopologicalRegularGrid::FacetsIterator::value()))
                TopologicalRegularGrid::FacetsIterator::advance();
        }
        void advance() {
            TopologicalRegularGrid::FacetsIterator::advance();
            while (TopologicalRegularGrid::FacetsIterator::valid() && !m_mesh->InMesh(TopologicalRegularGrid::FacetsIterator::value()))
                TopologicalRegularGrid::FacetsIterator::advance();
        }
        bool valid() const {        return TopologicalRegularGrid::FacetsIterator::valid(); }
        INDEX_TYPE value() const {  return TopologicalRegularGrid::FacetsIterator::value(); }
    };

    // -----------------------------------------------------------------------------
    //// also needs boundary!!! WILL USE IF rather than virutal function
    class CofacetsIterator : public TopologicalRegularGrid::CofacetsIterator {
    protected:
        const TopologicalRegularMaskedGrid* const m_mesh;
    public:
        CofacetsIterator(TopologicalRegularMaskedGrid* mesh) :
            TopologicalRegularGrid::CofacetsIterator(mesh), m_mesh(mesh) {}

        void begin(Vec3l const &coords) {
            TopologicalRegularGrid::CofacetsIterator::begin(coords);
            while (TopologicalRegularGrid::CofacetsIterator::valid() && !m_mesh->InMesh(TopologicalRegularGrid::CofacetsIterator::value()))
                TopologicalRegularGrid::CofacetsIterator::advance();
        }
        void begin(INDEX_TYPE const &cellid) {
            TopologicalRegularGrid::CofacetsIterator::begin(cellid);
            while (TopologicalRegularGrid::CofacetsIterator::valid() && !m_mesh->InMesh(TopologicalRegularGrid::CofacetsIterator::value()))
                TopologicalRegularGrid::CofacetsIterator::advance();
        }
        void advance() {
            TopologicalRegularGrid::CofacetsIterator::advance();
            while (TopologicalRegularGrid::CofacetsIterator::valid() && !m_mesh->InMesh(TopologicalRegularGrid::CofacetsIterator::value()))
                TopologicalRegularGrid::CofacetsIterator::advance();
        }
        bool valid() const {        return TopologicalRegularGrid::CofacetsIterator::valid();   }
        INDEX_TYPE value() const {  return TopologicalRegularGrid::CofacetsIterator::value();   }
    };

    // -----------------------------------------------------------------------------
    //// also needs boundary!!! WILL USE IF rather than virutal function
    class AdjacentCellsIterator : public TopologicalRegularGrid::AdjacentCellsIterator {
    protected:
        const TopologicalRegularMaskedGrid* const m_mesh;
    public:
        AdjacentCellsIterator(const TopologicalRegularMaskedGrid *const mesh) :
            TopologicalRegularGrid::AdjacentCellsIterator(mesh), m_mesh(mesh) {}

        void begin(Vec3l const &coords) {
            TopologicalRegularGrid::AdjacentCellsIterator::begin(coords);
            while (TopologicalRegularGrid::AdjacentCellsIterator::valid() && !m_mesh->InMesh(TopologicalRegularGrid::AdjacentCellsIterator::value()))
                TopologicalRegularGrid::AdjacentCellsIterator::advance();
        }
        void begin(INDEX_TYPE const &cellid) {
            TopologicalRegularGrid::AdjacentCellsIterator::begin(cellid);
            while (TopologicalRegularGrid::AdjacentCellsIterator::valid() && !m_mesh->InMesh(TopologicalRegularGrid::AdjacentCellsIterator::value()))
                TopologicalRegularGrid::AdjacentCellsIterator::advance();
        }
        void advance() {
            TopologicalRegularGrid::AdjacentCellsIterator::advance();
            while (TopologicalRegularGrid::AdjacentCellsIterator::valid() && !m_mesh->InMesh(TopologicalRegularGrid::AdjacentCellsIterator::value()))
                TopologicalRegularGrid::AdjacentCellsIterator::advance();
        }
        bool valid() const {        return TopologicalRegularGrid::AdjacentCellsIterator::valid();  }
        INDEX_TYPE value() const {  return TopologicalRegularGrid::AdjacentCellsIterator::value();  }
    };

    // -----------------------------------------------------------------------------
    //// also needs boundary!!! WILL USE IF rather than virutal function
    class CellVerticesIterator : public TopologicalRegularGrid::CellVerticesIterator {
    protected:
      const TopologicalRegularMaskedGrid* const m_mesh;
    public:
        CellVerticesIterator(const TopologicalRegularMaskedGrid *const mesh) :
            TopologicalRegularGrid::CellVerticesIterator(mesh), m_mesh(mesh) {}

        void begin(Vec3l const &coords) {
            TopologicalRegularGrid::CellVerticesIterator::begin(coords);
            while (TopologicalRegularGrid::CellVerticesIterator::valid() && !m_mesh->InMesh(TopologicalRegularGrid::CellVerticesIterator::value()))
                TopologicalRegularGrid::CellVerticesIterator::advance();
        }
        void begin(INDEX_TYPE const &cellid) {
            TopologicalRegularGrid::CellVerticesIterator::begin(cellid);
            while (TopologicalRegularGrid::CellVerticesIterator::valid() && !m_mesh->InMesh(TopologicalRegularGrid::CellVerticesIterator::value()))
                TopologicalRegularGrid::CellVerticesIterator::advance();
        }
        void advance() {
            TopologicalRegularGrid::CellVerticesIterator::advance();
            while (TopologicalRegularGrid::CellVerticesIterator::valid() && !m_mesh->InMesh(TopologicalRegularGrid::CellVerticesIterator::value()))
                TopologicalRegularGrid::CellVerticesIterator::advance();
        }
        bool valid() const {        return TopologicalRegularGrid::CellVerticesIterator::valid();   }
        INDEX_TYPE value() const {  return TopologicalRegularGrid::CellVerticesIterator::value();   }
    };
    // -----------------------------------------------------------------------------
};
}   // end of namespace
#endif
